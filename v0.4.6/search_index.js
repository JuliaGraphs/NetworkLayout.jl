var documenterSearchIndex = {"docs":
[{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = NetworkLayout","category":"page"},{"location":"interface/#Layout-Interface","page":"Interface","title":"Layout Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"At its core, each layout algorithm is a mapping ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"graph ↦ node_positions","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"where each layout has several parameters. The main goal of the following interface is to keep the separation between parameters and function call.  Each layout is implemented as subtype of AbstractLayout.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"AbstractLayout","category":"page"},{"location":"interface/#NetworkLayout.AbstractLayout","page":"Interface","title":"NetworkLayout.AbstractLayout","text":"AbstractLayout{Dim,Ptype}\n\nAbstract supertype for all layouts. Each layout Layout <: AbstractLayout needs to implement\n\nlayout(::Layout, adj_matrix)::Vector{Point{Dim,Ptype}}\n\nwhich takes the adjacency matrix representation of a network and returns a list of node positions. Each Layout object holds all of the necessary parameters.\n\nThe type parameters specify the returntype Vector{Point{Dim,Ptype}}:\n\nDim: the dimensionality of the layout (i.e. 2 or 3)\nPtype: the type of the returned points (i.e. Float32 or Float64)\n\nBy implementing layout the Layout also inherits the function-like property\n\nLayout(; kwargs...)(adj_matrix) -> node_positions\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"Therefore, each LayoutAlgorithm <: AbstractLayout is a functor and can be passed around as a function graph ↦ node_positions which encapsulates all the parameters. This is handy for plotting libraries such as GraphMakie.jl.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"There are some additional guidelines:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"All of the parameters should be keyword arguments, i.e. it should be allways possible to call LayoutAlgorithm() without specifying any parameters.\nAlgorithms should allways return Vector{Point{Dim,Ptype}}. If the type or dimensions can be altered use the keywords dim and Ptype for it.\nSome parameters may depend on the specific network (i.e. length of start positions vector). If possible, there should be a fallback option (i.e. truncate the list of start positions if network is to small or append with random values).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"It is convenient to define the lowercase functions ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"layoutalgorithm(g; kwargs...) = layout(LayoutAlgorihtm(; kwargs...), g)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"which can done using this macro:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"@addcall","category":"page"},{"location":"interface/#NetworkLayout.@addcall","page":"Interface","title":"NetworkLayout.@addcall","text":"@addcall\n\nAnnotate subtypes of AbstractLayout to create a lowercase function call for them.\n\n@addcall struct MyLayout{Dim, Ptype} <: AbstractLayout{Dim, Ptype}\n    para\nend\n\nwill add the function\n\nmylayout(g; kwargs...) = layout(MyLayout(; kwargs...), g)\n\n\n\n\n\n","category":"macro"},{"location":"interface/#Iterative-Layouts","page":"Interface","title":"Iterative Layouts","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Iterative layouts are a specific type of layouts which produce a sequence of positions rather than a single list of positions. Those algorithms are implemented as subtypes of IterativeLayout:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"IterativeLayout","category":"page"},{"location":"interface/#NetworkLayout.IterativeLayout","page":"Interface","title":"NetworkLayout.IterativeLayout","text":"IterativeLayout{Dim,Ptype} <: AbstractLayout{Dim,Ptype}\n\nAbstract supertype for iterative layouts. Instead of implementing layout directly, subtypes Algorithm<:IterativeLayout need to implement the iterator interface\n\nBase.iterate(iter::LayoutIterator{<:Algorithm})\nBase.iterate(iter::LayoutIterator{<:Algorithm}, state)\n\nwhere the iteration item is a Vector{Point{Dim,Ptype}} and the iteration state depends on the algorithm.\n\nBy implementing the iterator interface the Algorithm inherits the layout and function-like call\n\nlayout(algo::Algorithm, adj_matrix) -> node_postions\nAlgorithm(; kwargs...)(adj_matrix) -> node_positions\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"One can instantiate an iterable object LayoutIterator","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"LayoutIterator","category":"page"},{"location":"interface/#NetworkLayout.LayoutIterator","page":"Interface","title":"NetworkLayout.LayoutIterator","text":"LayoutIterator{T<:IterativeLayout,M<:AbstractMatrix}(algorithm, adj_matrix)\n\nThis type bundles an IterativeLayout with an adjacency matrix to form an iterable object whose items are the node positions.\n\nExample\n\nfor p in LayoutIterator(Stress(), adj_matrix)\n    # do stuff with positions p\nend\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NetworkLayout","category":"page"},{"location":"#NetworkLayout","page":"Home","title":"NetworkLayout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the Documentation for NetworkLayout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All example images on this page are created using Makie.jl and the graphplot recipe from GraphMakie.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\nCairoMakie.activate!(type=\"png\") # hide\nset_theme!(resolution=(800, 400)) #hide\nusing NetworkLayout\nusing GraphMakie, Graphs\nnothing #hide","category":"page"},{"location":"#Basic-Usage-and-Algorithms","page":"Home","title":"Basic Usage & Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of the algorithms follow the Layout Interface. Each layout algorithm is represented by a type LayoutAlgorithm <: AbstractLayout. The parameters of each layout can be set with keyword arguments. The LayoutAlgorithm object itself is callable and transforms the adjacency matrix and returns a list of Point{N,T} from GeometryBasics.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"alg = LayoutAlgorithm(; p1=\"foo\", p2=:bar)\npositions = alg(adj_matrix)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each of the layouts comes with a lowercase function version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"positions = layoutalgorithm(adj_matrix; p1=\"foo\", b2=:bar)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instead of using the adjacency matrix you can use AbstractGraph types from Graphs.jl directly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = complete_graph(10)\npositions = layoutalgorithm(g)","category":"page"},{"location":"#Scalable-Force-Directed-Placement","page":"Home","title":"Scalable Force Directed Placement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SFDP","category":"page"},{"location":"#NetworkLayout.SFDP","page":"Home","title":"NetworkLayout.SFDP","text":"SFDP(; kwargs...)(adj_matrix)\nsfdp(adj_matrix; kwargs...)\n\nUsing the Spring-Electric model suggested by Hu (2005, The Mathematica Journal, pdf).\n\nForces are calculated as:\n\n    f_attr(i,j) = ‖xi - xj‖ ² / K ,    i<->j\n    f_repln(i,j) = -CK² / ‖xi - xj‖ ,  i!=j\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\ntol=1.0: Stop if position changes of last step Δp <= tol*K for all nodes\nC=0.2, K=1.0: Parameters to tweak forces.\niterations=100: maximum number of iterations\ninitialpos=Point{dim,Ptype}[]\nProvide Vector or Dict of initial positions. All positions will be initialized using random coordinates between [-1,1]. Random positions will be overwritten using the key-val-pairs provided by this argument.\npin=[]: Pin node positions (won't be updated). Can be given as Vector or Dict  of node index -> value pairings. Values can be either\n(12, 4.0) : overwrite initial position and pin\ntrue/false : pin this position\n(true, false, false) : only pin certain coordinates\nseed=1: Seed for random initial positions.\n\n\n\n\n\n","category":"type"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"g = wheel_graph(10)\nlayout = SFDP(Ptype=Float32, tol=0.01, C=0.2, K=1)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f","category":"page"},{"location":"#Iterator-Example","page":"Home","title":"Iterator Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iterator = LayoutIterator(layout, g)\nrecord(f, \"sfdp_animation.mp4\", iterator; framerate = 10) do pos\n    p[:node_pos][] = pos\n    autolimits!(ax)\nend\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: sfdp animation)","category":"page"},{"location":"#Buchheim-Tree-Drawing","page":"Home","title":"Buchheim Tree Drawing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Buchheim","category":"page"},{"location":"#NetworkLayout.Buchheim","page":"Home","title":"NetworkLayout.Buchheim","text":"Buchheim(; kwargs...)(adj_matrix)\nBuchheim(; kwargs...)(adj_list)\nbuchheim(adj_matrix; kwargs...)\nbuchheim(adj_list; kwargs...)\n\nUsing the algorithm proposed by Buchheim, Junger and Leipert (2002, doi 10.1007/3-540-36151-0_32).\n\nTakes adjacency matrix or list representation of given tree and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}.\nnodesize=Float64[]\nDetermines the size of each of the node. If network size does not match the length of nodesize fill up with ones or truncate given parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Example-2","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"adj_matrix = [0 1 1 0 0 0 0 0 0 0;\n              0 0 0 0 1 1 0 0 0 0;\n              0 0 0 1 0 0 1 0 1 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 1 0 1;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0 0 0]\ng = SimpleDiGraph(adj_matrix)\nlayout = Buchheim()\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spring/Repulsion-Model","page":"Home","title":"Spring/Repulsion Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spring","category":"page"},{"location":"#NetworkLayout.Spring","page":"Home","title":"NetworkLayout.Spring","text":"Spring(; kwargs...)(adj_matrix)\nspring(adj_matrix; kwargs...)\n\nUse the spring/repulsion model of Fruchterman and Reingold (1991, doi 10.1002/spe.4380211102) with\n\nAttractive force:  f_a(d) =  d^2 / k\nRepulsive force:  f_r(d) = -k^2 / d\n\nwhere d is distance between two vertices and the optimal distance between vertices k is defined as C * sqrt( area / num_vertices ) where C is a parameter we can adjust\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\nC=2.0: Constant to fiddle with density of resulting layout\niterations=100: maximum number of iterations\ninitialtemp=2.0: Initial \"temperature\", controls movement per iteration\ninitialpos=Point{dim,Ptype}[]\nProvide Vector or Dict of initial positions. All positions will be initialized using random coordinates between [-1,1]. Random positions will be overwritten using the key-val-pairs provided by this argument.\npin=[]: Pin node positions (won't be updated). Can be given as Vector or Dict  of node index -> value pairings. Values can be either\n(12, 4.0) : overwrite initial position and pin\ntrue/false : pin this position\n(true, false, false) : only pin certain coordinates\nseed=1: Seed for random initial positions.\n\n\n\n\n\n","category":"type"},{"location":"#Example-3","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"g = smallgraph(:cubical)\nlayout = Spring(Ptype=Float32)\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Iterator-Example-2","page":"Home","title":"Iterator Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iterator = LayoutIterator(layout, g)\nrecord(f, \"spring_animation.mp4\", iterator; framerate = 10) do pos\n    p[:node_pos][] = pos\n    autolimits!(ax)\nend\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: spring animation)","category":"page"},{"location":"#Stress-Majorization","page":"Home","title":"Stress Majorization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stress","category":"page"},{"location":"#NetworkLayout.Stress","page":"Home","title":"NetworkLayout.Stress","text":"Stress(; kwargs...)(adj_matrix)\nstress(adj_matrix; kwargs...)\n\nCompute graph layout using stress majorization. Takes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nThe main equation to solve is (8) in Gansner, Koren and North (2005, doi 10.1007/978-3-540-31843-9_25).\n\nInputs:\n\nadj_matrix: Matrix of pairwise distances.\n\nKeyword Arguments\n\ndim=2, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\niterations=:auto: maximum number of iterations (:auto means 400*N^2 where N are the number of vertices)\nabstols=0\nAbsolute tolerance for convergence of stress. The iterations terminate if the  difference between two successive stresses is less than abstol.\nreltols=10e-6\nRelative tolerance for convergence of stress. The iterations terminate if the difference between two successive stresses relative to the current stress is less than reltol.\nabstolx=10e-6\nAbsolute tolerance for convergence of layout. The iterations terminate if the Frobenius norm of two successive layouts is less than abstolx.\nweights=Array{Float64}(undef, 0, 0)\nMatrix of weights. If empty (i.e. not specified), defaults to weights[i,j] = δ[i,j]^-2 if δ[i,j] is nonzero, or 0 otherwise.\ninitialpos=Point{dim,Ptype}[]\nProvide Vector or Dict of initial positions. All positions will be initialized using random coordinates from normal distribution. Random positions will be overwritten using the key-val-pairs provided by this argument.\npin=[]: Pin node positions (won't be updated). Can be given as Vector or Dict  of node index -> value pairings. Values can be either\n(12, 4.0) : overwrite initial position and pin\ntrue/false : pin this position\n(true, false, false) : only pin certain coordinates\nseed=1: Seed for random initial positions.\n\n\n\n\n\n","category":"type"},{"location":"#Example-4","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"g = SimpleGraph(936)\nfor l in eachline(joinpath(@__DIR__,\"..\",\"..\",\"test\",\"jagmesh1.mtx\"))\n    s = split(l, \" \")\n    src, dst = parse(Int, s[1]), parse(Int, s[2])\n    src != dst && add_edge!(g, src, dst)\nend\n\nlayout = Stress(Ptype=Float32)\nf, ax, p = graphplot(g; layout=layout, node_size=3, edge_width=1)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Iterator-Example-3","page":"Home","title":"Iterator Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iterator = LayoutIterator(layout, g)\nrecord(f, \"stress_animation.mp4\", iterator; framerate = 7) do pos\n    p[:node_pos][] = pos\n    autolimits!(ax)\nend\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: stress animation)","category":"page"},{"location":"#Shell/Circular-Layout","page":"Home","title":"Shell/Circular Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shell","category":"page"},{"location":"#NetworkLayout.Shell","page":"Home","title":"NetworkLayout.Shell","text":"Shell(; kwargs...)(adj_matrix)\nshell(adj_matrix; kwargs...)\n\nPosition nodes in concentric circles. Without further arguments all nodes will be placed on a circle with radius 1.0. Specify placement of nodes using the nlist argument.\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}.\nnlist=Vector{Int}[]\nVector of Vector of node indices. Tells the algorithm, which nodes to place on which shell from inner to outer. Nodes which are not present in this list will be place on additional outermost shell.\n\nThis function started as a copy from IainNZ's GraphLayout.jl\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"g = smallgraph(:petersen)\nlayout = Shell(nlist=[6:10,])\nf, ax, p = graphplot(g, layout=layout)\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#SquareGrid-Layout","page":"Home","title":"SquareGrid Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SquareGrid","category":"page"},{"location":"#NetworkLayout.SquareGrid","page":"Home","title":"NetworkLayout.SquareGrid","text":"SquareGrid(; kwargs...)(adj_matrix)\nsquaregrid(adj_matrix; kwargs...)\n\nPosition nodes on a 2 dimensional rectagular grid. The nodes are placed in order from upper left to lower right. To skip positions see skip argument.\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\nPtype=Float64: Determines the output type Point{2,Ptype}\ncols=:auto: Columns of the grid, the rows are determined automatic. If :auto the layout will be square-ish.\ndx=Ptype(1), dy=Ptype(-1): Ofsets between rows/cols.\nskip=Tuple{Int,Int}[]: Specify positions to skip when placing nodes. skip=[(i,j)] means to keep the position in the i-th row and j-th column empty.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"g = Grid((12,4))\nlayout = SquareGrid(cols=12)\nf, ax, p = graphplot(g, layout=layout, nlabels=repr.(1:nv(g)), nlabels_textsize=10, nlabels_distance=5)\nylims!(-4.5,.5); hidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect(); f #hide","category":"page"},{"location":"#Spectral-Layout","page":"Home","title":"Spectral Layout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral","category":"page"},{"location":"#NetworkLayout.Spectral","page":"Home","title":"NetworkLayout.Spectral","text":"Spectral(; kwargs...)(adj_matrix)\nspectral(adj_matrix; kwargs...)\n\nThis algorithm uses the technique of Spectral Graph Drawing. For reference see Koren (2003, doi 10.1007/3-540-45071-8_50).\n\nTakes adjacency matrix representation of a network and returns coordinates of the nodes.\n\nKeyword Arguments\n\ndim=3, Ptype=Float64: Determines dimension and output type Point{dim,Ptype}.\nnodeweights=Float64[]: Vector of weights. If network size does not match the length of nodesize use ones instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"g = watts_strogatz(1000, 5, 0.03; seed=5)\nlayout = Spectral(dim=2)\nf, ax, p = graphplot(g, layout=layout, node_size=0.0, edge_width=1.0)\nhidedecorations!(ax); hidespines!(ax); f #hide\nf #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"set_theme!(resolution=(800, 800)) #hide\nusing Random; Random.seed!(5) # hide\nlayout = Spectral()\nf, ax, p = graphplot(g, layout=layout, node_size=0.0, edge_width=1.0)\nf #hide","category":"page"},{"location":"#pin-Positions-in-Interative-Layouts","page":"Home","title":"pin Positions in Interative Layouts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sometimes it is desired to fix the positions of a few nodes while arranging the rest \"naturally\" around them. The iterative layouts Stress, Spring and SFDP allow to pin nodes to certain positions, i.e. those node will stay fixed during the iteration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = SimpleGraph(vcat(hcat(zeros(4,4), ones(4,4)), hcat(ones(4,4), zeros(4,4))))\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The keyword argument pin takes a Vector or a Dict of key - value pairs. The key has to be the index of the node. The value can take three forms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"idx => Point2(x,y) or idx => (x,y) overwrites the initial position of that vertex and pins it there,\nidx => true/false pins or unpins the vertex, position is taken from initialpos-keyword argument or random,\nidx => (false, true) allows for fine control over which coordinate to pin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"initialpos = Dict(1=>Point2f(-1,0.5),\n                  3=>Point2f(1,0),\n                  4=>Point2f(1,0))\npin = Dict(1=>true,\n           2=>(-1,-0.5),\n           3=>(true, false),\n           4=>(true, false))\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example animation on how those keyword arguments effect different iterative layouts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"springl = Spring(;initialpos, pin, seed=11) #2\nsfdpl   = SFDP(;initialpos, pin, tol=0.0)\nstressl = Stress(;initialpos, pin, reltols=0.0, abstolx=0.0, iterations=100)\n\nf = Figure(resolution=(1200,500))\nax1 = f[1,1] = Axis(f; title=\"Spring\")\nax2 = f[1,2] = Axis(f; title=\"SFDP\")\nax3 = f[1,3] = Axis(f; title=\"Stress\")\n\nfor ax in [ax1, ax2, ax3]\n    xlims!(ax,-2,2); ylims!(ax,-1.4,1.4); vlines!(ax, 1; color=:red); hidespines!(ax); hidedecorations!(ax)\nend\n\nnode_color = vcat(:green, :green, :red, :red, [:black for _ in 1:4])\nnode_size = vcat([40 for _ in 1:4], [20 for _ in 1:4])\nnlabels = vcat(\"1\", \"2\", \"3\", \"4\", [\"\" for _ in 1:4])\nnlabels_align = (:center, :center)\nnlabels_color = :white\np1 = graphplot!(ax1, g; layout=springl, node_color, node_size, nlabels, nlabels_align, nlabels_color)\np2 = graphplot!(ax2, g; layout=sfdpl, node_color, node_size, nlabels, nlabels_align, nlabels_color)\np3 = graphplot!(ax3, g; layout=stressl, node_color, node_size, nlabels, nlabels_align, nlabels_color)\n\niterators = [LayoutIterator(l, g) for l in (springl, sfdpl, stressl)]\nrecord(f, \"pin_animation.mp4\", zip(iterators...); framerate = 10) do (pos1, pos2, pos3)\n    p1[:node_pos][] = pos1\n    p2[:node_pos][] = pos2\n    p3[:node_pos][] = pos3\nend\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: pin animation)","category":"page"}]
}
